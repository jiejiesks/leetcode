## 一、动态规划的三大步骤

动态规划即利用历史记录来避免重复计算。而这些历史记录，我们得需要一些变量来保存，一般是用[一维数组](https://so.csdn.net/so/search?q=一维数组&spm=1001.2101.3001.7020)或者二维数组来保存。下面我们先来讲下做动态规划题很重要的三个步骤：
**第一步骤**：定义[数组](https://so.csdn.net/so/search?q=数组&spm=1001.2101.3001.7020)元素的含义：我们会用一个数组，来保存历史数组，假设用一维数组 dp[] 吧。这个时候有一个非常重要的点，就是规定你这个数组元素的含义，例如你的 dp[i] 是代表什么意思？
**第二步骤**：找出数组元素之间的关系式：我觉得动态规划，还是有一点类似于高中学习的归纳法，当我们要计算 dp[n] 时，是可以利用 dp[n-1]，dp[n-2]……dp[1]，来推出 dp[n] 的，也就是可以利用历史数据来推出新的元素值，所以我们要找出数组元素之间的关系式，例如 dp[n] = dp[n-1] + dp[n-2]，这个就是他们的关系式了。而这一步，也是最难的一步，后面我会讲几种类型的题来说。
`动态规划方法的思想是：将原问题分解为若干子问题，称为「最优子结构」，通过求解子问题完成对最终问题的求解。对于重复出现的子问题，在第一次出现时对其进行求解，然后保存其结果，从而在求解后续的子问题时可以直接利用先前得到的结果。`
**第三步骤**：找出初始值：学过数学归纳法的都知道，虽然我们知道了数组元素之间的关系式，例如 dp[n] = dp[n-1] + dp[n-2]，我们可以通过 dp[n-1] 和 dp[n-2] 来计算 dp[n]，但是，我们得知道初始值啊，例如一直推下去的话，会由 dp[3] = dp[2] + dp[1]。而 dp[2] 和 dp[1] 是不能再分解的了，所以我们必须要能够直接获得 dp[2] 和 dp[1] 的值，而这，就是所谓的初始值。
由了初始值，并且有了数组元素之间的关系式，那么我们就可以得到 dp[n] 的值了，而 dp[n] 的含义是由你来定义的，你想求什么，就定义它是什么，这样，这道题也就解出来了。



在寻找初始值的时候，一定要注意不要找漏了，dp[2] 也算是一个初始值，不能通过公式计算得出。有人可能会说，我想不到怎么办？这个很好办，多做几道题就可以了。





1.规定dp数组的含义

2.找dp前后的推导关系

3.找初始值

```
vector<vector<int>> res; /二维

for(int i=2;i<numRows;++i){

​      vector<int> temp(i+1,0);

​      temp[0]=1;

​      for(int j=1;j<i;++j){

​        temp[j] = res[i-1][j-1] + res[i-1][j];

​      }

​      temp[i]=1;

​      res.push_back(temp);

​    }
```

